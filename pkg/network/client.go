/*
Copyright 2020 The arhat.dev Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package network

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"math"
	"strings"
	"text/template"

	"arhat.dev/abbot-proto/abbotgopb"
	"arhat.dev/aranya-proto/aranyagopb"
)

const (
	resolvConfTemplate = `# resolv.conf generated by arhat
{{ if gt (len .Searches) 0 -}}
search {{- range .Searches }} {{ . }} {{- end -}}
{{ end }}
{{ range .Servers -}}
nameserver {{ . }}
{{ end }}

{{- if gt (len .Options) 0 -}}
options {{- range .Options }} {{ . }} {{- end -}}
{{ end }}
`
)

var (
	resolvTemplate *template.Template
	ErrEmptyCIDR   = errors.New("cidr is empty")
)

func init() {
	var err error
	resolvTemplate, err = template.New("").Parse(resolvConfTemplate)
	if err != nil {
		panic(err)
	}
}

func NewNetworkClient(execAbbotFunc func(subCmd []string, output io.Writer) error) *Client {
	return &Client{
		execAbbot: execAbbotFunc,
	}
}

type Client struct {
	execAbbot func(subCmd []string, output io.Writer) error
}

func (c *Client) CreateResolvConf(nameservers, searches, options []string) ([]byte, error) {
	if len(nameservers) == 0 {
		nameservers = []string{"::1", "127.0.0.1"}
	}

	if len(searches) == 0 {
		searches = []string{"."}
	}

	buf := new(bytes.Buffer)
	err := resolvTemplate.Execute(buf, map[string][]string{
		"Servers":  nameservers,
		"Searches": searches,
		"Options":  options,
	})
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (c *Client) CreateLink(pauseCtrID string, pid uint32, ctrOpts *aranyagopb.CreateOptions) (string, error) {
	err := c.doRequestNetworkConfigUpdate(ctrOpts.NetworkOptions)
	if err != nil {
		return "", err
	}

	var capArgs []*abbotgopb.CNICapArgs
	capArgs = append(capArgs, &abbotgopb.CNICapArgs{
		Option: &abbotgopb.CNICapArgs_DnsConfigArg{
			DnsConfigArg: &abbotgopb.CNICapArgs_DNSConfig{
				Servers:  ctrOpts.NameServers,
				Searches: ctrOpts.SearchDomains,
				Options:  ctrOpts.DnsOptions,
			},
		},
	})

	// ipRange cap arg for cni
	netOpts := ctrOpts.NetworkOptions
	if netOpts.Ipv4PodCidr != "" {
		capArgs = append(capArgs, &abbotgopb.CNICapArgs{
			Option: &abbotgopb.CNICapArgs_IpRangeArg{
				IpRangeArg: &abbotgopb.CNICapArgs_IPRange{
					Subnet: netOpts.Ipv4PodCidr,
				},
			},
		})
	}

	if netOpts.Ipv6PodCidr != "" {
		capArgs = append(capArgs, &abbotgopb.CNICapArgs{
			Option: &abbotgopb.CNICapArgs_IpRangeArg{
				IpRangeArg: &abbotgopb.CNICapArgs_IPRange{
					Subnet: netOpts.Ipv6PodCidr,
				},
			},
		})
	}

	if b := netOpts.Bandwidth; b != nil {
		capArgs = append(capArgs, &abbotgopb.CNICapArgs{
			Option: &abbotgopb.CNICapArgs_BandwidthArg{
				BandwidthArg: &abbotgopb.CNICapArgs_Bandwidth{
					IngressRate: b.IngressRate,
					EgressRate:  b.EgressRate,
					// currently it's unlimited in kubelet
					IngressBurst: math.MaxInt32,
					EgressBurst:  math.MaxInt32,
				},
			},
		})
	}

	for _, port := range ctrOpts.Ports {
		// portMapping cap args for cni
		capArgs = append(capArgs, &abbotgopb.CNICapArgs{
			Option: &abbotgopb.CNICapArgs_PortMapArg{
				PortMapArg: &abbotgopb.CNICapArgs_PortMap{
					ContainerPort: port.ContainerPort,
					HostPort:      port.HostPort,
					Protocol:      strings.ToLower(port.Protocol),
					HostIp:        port.HostIp,
				},
			},
		})
	}

	ipAddr, err := c.doRequest(newReqForLinkCreate(ctrOpts.Namespace, ctrOpts.Name, pauseCtrID, pid, capArgs))
	if err != nil {
		return "", err
	}

	return ipAddr, nil
}

func (c *Client) DeleteLink(pauseCtrID string, pid uint32) error {
	_, err := c.doRequest(newReqForLinkDelete(pauseCtrID, pid))
	if err != nil {
		return err
	}

	return nil
}

func (c *Client) RestoreLink(pauseCtrID string, pid uint32) error {
	_, err := c.doRequest(newReqForRestoreAddress(pauseCtrID, pid))
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) GetAddress(pid uint32) (string, error) {
	ip, err := c.doRequest(newReqForGetAddress(pid))
	if err != nil {
		return "", err
	}

	return ip, nil
}

// EnsureAddress will ensure container's address is in the podCIDR range
func (c *Client) EnsureAddress(pauseCtrID string, pid uint32, options *aranyagopb.NetworkOptions) (string, error) {
	err := c.doRequestNetworkConfigUpdate(options)
	if err != nil {
		return "", err
	}

	ip, err := c.doRequest(newReqForUpdateLink(pauseCtrID, options.Ipv4PodCidr, options.Ipv6PodCidr, pid))
	if err != nil {
		return "", err
	}

	return ip, nil
}

func (c *Client) doRequestNetworkConfigUpdate(options *aranyagopb.NetworkOptions) error {
	var (
		ipv4Subnet = options.Ipv4PodCidr
		ipv6Subnet = options.Ipv6PodCidr
	)

	if ipv4Subnet == "" && ipv6Subnet == "" {
		return ErrEmptyCIDR
	}

	_, err := c.doRequest(newReqForConfigUpdate(ipv4Subnet, ipv6Subnet))
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) doRequest(req *abbotgopb.Request) (ip string, err error) {
	encodedReq, err := encodeRequest(req)
	if err != nil {
		return "", err
	}

	output := new(bytes.Buffer)
	err = c.execAbbot([]string{"request", encodedReq}, output)
	result := output.String()

	if err != nil {
		if result != "" {
			return "", errors.New(result)
		}

		return "", err
	}
	respBytes, err := base64.StdEncoding.DecodeString(result)
	if err != nil {
		// not base64 encoded, error happened
		return "", errors.New(result)
	}

	resp := new(abbotgopb.Response)
	err = resp.Unmarshal(respBytes)
	if err != nil {
		return "", err
	}

	switch r := resp.GetResp().(type) {
	case *abbotgopb.Response_AddrResp:
		return r.AddrResp.Ip, nil
	case *abbotgopb.Response_EmptyResp:
		return "", nil
	default:
		return "", fmt.Errorf("unexpected cni response: %v", r)
	}
}

func newReqForLinkCreate(
	podNamespace, podName, pauseCtrID string,
	pid uint32,
	capArgs []*abbotgopb.CNICapArgs,
) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.CREATE,
		Option: &abbotgopb.Request_CreateOpts{
			CreateOpts: &abbotgopb.CreateOptions{
				ContainerId: pauseCtrID,
				Pid:         pid,
				CniArgs: map[string]string{
					"IgnoreUnknown":              "true",
					"K8S_POD_NAMESPACE":          podNamespace,
					"K8S_POD_NAME":               podName,
					"K8S_POD_INFRA_CONTAINER_ID": pauseCtrID,
				},
				CapArgs: capArgs,
			},
		},
	}
}

func newReqForLinkDelete(pauseCtrID string, pid uint32) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.DELETE,
		Option: &abbotgopb.Request_DeleteLinkOpts{
			DeleteLinkOpts: &abbotgopb.DeleteLinkOptions{
				ContainerId: pauseCtrID,
				Pid:         pid,
			},
		},
	}
}

func newReqForConfigUpdate(ipv4Subnet, ipv6Subnet string) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.UPDATE_CONFIG,
		Option: &abbotgopb.Request_ConfigOpts{
			ConfigOpts: &abbotgopb.ConfigOptions{
				Ipv4Subnet: ipv4Subnet,
				Ipv6Subnet: ipv6Subnet,
			},
		},
	}
}

func newReqForGetAddress(pid uint32) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.GET_ADDR,
		Option: &abbotgopb.Request_GetAddrOpts{
			GetAddrOpts: &abbotgopb.GetAddrOptions{
				Pid: pid,
			},
		},
	}
}

func newReqForUpdateLink(containerID, ipv4PodCIDR, ipv6PodCIDR string, pid uint32) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.UPDATE_LINK,
		Option: &abbotgopb.Request_UpdateLinkOpts{
			UpdateLinkOpts: &abbotgopb.UpdateLinkOptions{
				ContainerId: containerID,
				Pid:         pid,
				Ipv4PodCidr: ipv4PodCIDR,
				Ipv6PodCidr: ipv6PodCIDR,
			},
		},
	}
}

func newReqForRestoreAddress(containerID string, pid uint32) *abbotgopb.Request {
	return &abbotgopb.Request{
		Action: abbotgopb.RESTORE_LINK,
		Option: &abbotgopb.Request_RestoreLinkOpts{
			RestoreLinkOpts: &abbotgopb.RestoreLinkOptions{
				ContainerId: containerID,
				Pid:         pid,
			},
		},
	}
}

func encodeRequest(req *abbotgopb.Request) (string, error) {
	data, err := req.Marshal()
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(data), nil
}
