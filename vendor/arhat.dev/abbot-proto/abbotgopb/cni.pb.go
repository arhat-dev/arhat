// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cni.proto

package abbotgopb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Request_ActionType int32

const (
	_invalid      Request_ActionType = 0
	CREATE        Request_ActionType = 1
	DELETE        Request_ActionType = 2
	UPDATE_CONFIG Request_ActionType = 3
	GET_ADDR      Request_ActionType = 4
	UPDATE_LINK   Request_ActionType = 5
	RESTORE_LINK  Request_ActionType = 6
)

var Request_ActionType_name = map[int32]string{
	0: "_invalid",
	1: "CREATE",
	2: "DELETE",
	3: "UPDATE_CONFIG",
	4: "GET_ADDR",
	5: "UPDATE_LINK",
	6: "RESTORE_LINK",
}

var Request_ActionType_value = map[string]int32{
	"_invalid":      0,
	"CREATE":        1,
	"DELETE":        2,
	"UPDATE_CONFIG": 3,
	"GET_ADDR":      4,
	"UPDATE_LINK":   5,
	"RESTORE_LINK":  6,
}

func (Request_ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{7, 0}
}

type CNICapArgs struct {
	// Types that are valid to be assigned to Option:
	//	*CNICapArgs_PortMapArg
	//	*CNICapArgs_BandwidthArg
	//	*CNICapArgs_IpRangeArg
	//	*CNICapArgs_DnsConfigArg
	Option isCNICapArgs_Option `protobuf_oneof:"option"`
}

func (m *CNICapArgs) Reset()      { *m = CNICapArgs{} }
func (*CNICapArgs) ProtoMessage() {}
func (*CNICapArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{0}
}
func (m *CNICapArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs.Merge(m, src)
}
func (m *CNICapArgs) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs proto.InternalMessageInfo

type isCNICapArgs_Option interface {
	isCNICapArgs_Option()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CNICapArgs_PortMapArg struct {
	PortMapArg *CNICapArgs_PortMap `protobuf:"bytes,1,opt,name=port_map_arg,json=portMapArg,proto3,oneof" json:"port_map_arg,omitempty"`
}
type CNICapArgs_BandwidthArg struct {
	BandwidthArg *CNICapArgs_Bandwidth `protobuf:"bytes,2,opt,name=bandwidth_arg,json=bandwidthArg,proto3,oneof" json:"bandwidth_arg,omitempty"`
}
type CNICapArgs_IpRangeArg struct {
	IpRangeArg *CNICapArgs_IPRange `protobuf:"bytes,3,opt,name=ip_range_arg,json=ipRangeArg,proto3,oneof" json:"ip_range_arg,omitempty"`
}
type CNICapArgs_DnsConfigArg struct {
	DnsConfigArg *CNICapArgs_DNSConfig `protobuf:"bytes,4,opt,name=dns_config_arg,json=dnsConfigArg,proto3,oneof" json:"dns_config_arg,omitempty"`
}

func (*CNICapArgs_PortMapArg) isCNICapArgs_Option()   {}
func (*CNICapArgs_BandwidthArg) isCNICapArgs_Option() {}
func (*CNICapArgs_IpRangeArg) isCNICapArgs_Option()   {}
func (*CNICapArgs_DnsConfigArg) isCNICapArgs_Option() {}

func (m *CNICapArgs) GetOption() isCNICapArgs_Option {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *CNICapArgs) GetPortMapArg() *CNICapArgs_PortMap {
	if x, ok := m.GetOption().(*CNICapArgs_PortMapArg); ok {
		return x.PortMapArg
	}
	return nil
}

func (m *CNICapArgs) GetBandwidthArg() *CNICapArgs_Bandwidth {
	if x, ok := m.GetOption().(*CNICapArgs_BandwidthArg); ok {
		return x.BandwidthArg
	}
	return nil
}

func (m *CNICapArgs) GetIpRangeArg() *CNICapArgs_IPRange {
	if x, ok := m.GetOption().(*CNICapArgs_IpRangeArg); ok {
		return x.IpRangeArg
	}
	return nil
}

func (m *CNICapArgs) GetDnsConfigArg() *CNICapArgs_DNSConfig {
	if x, ok := m.GetOption().(*CNICapArgs_DnsConfigArg); ok {
		return x.DnsConfigArg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CNICapArgs) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CNICapArgs_PortMapArg)(nil),
		(*CNICapArgs_BandwidthArg)(nil),
		(*CNICapArgs_IpRangeArg)(nil),
		(*CNICapArgs_DnsConfigArg)(nil),
	}
}

type CNICapArgs_PortMap struct {
	ContainerPort int32  `protobuf:"varint,1,opt,name=container_port,json=containerPort,proto3" json:"containerPort"`
	HostPort      int32  `protobuf:"varint,2,opt,name=host_port,json=hostPort,proto3" json:"hostPort"`
	Protocol      string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol"`
	HostIp        string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"hostIP"`
}

func (m *CNICapArgs_PortMap) Reset()      { *m = CNICapArgs_PortMap{} }
func (*CNICapArgs_PortMap) ProtoMessage() {}
func (*CNICapArgs_PortMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{0, 0}
}
func (m *CNICapArgs_PortMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_PortMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_PortMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_PortMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_PortMap.Merge(m, src)
}
func (m *CNICapArgs_PortMap) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_PortMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_PortMap.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_PortMap proto.InternalMessageInfo

func (m *CNICapArgs_PortMap) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *CNICapArgs_PortMap) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *CNICapArgs_PortMap) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *CNICapArgs_PortMap) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

type CNICapArgs_Bandwidth struct {
	IngressRate  int32 `protobuf:"varint,1,opt,name=ingress_rate,json=ingressRate,proto3" json:"ingressRate,omitempty"`
	IngressBurst int32 `protobuf:"varint,2,opt,name=ingress_burst,json=ingressBurst,proto3" json:"ingressBurst,omitempty"`
	EgressRate   int32 `protobuf:"varint,3,opt,name=egress_rate,json=egressRate,proto3" json:"egressRate,omitempty"`
	EgressBurst  int32 `protobuf:"varint,4,opt,name=egress_burst,json=egressBurst,proto3" json:"egressBurst,omitempty"`
}

func (m *CNICapArgs_Bandwidth) Reset()      { *m = CNICapArgs_Bandwidth{} }
func (*CNICapArgs_Bandwidth) ProtoMessage() {}
func (*CNICapArgs_Bandwidth) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{0, 1}
}
func (m *CNICapArgs_Bandwidth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_Bandwidth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_Bandwidth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_Bandwidth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_Bandwidth.Merge(m, src)
}
func (m *CNICapArgs_Bandwidth) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_Bandwidth) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_Bandwidth.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_Bandwidth proto.InternalMessageInfo

func (m *CNICapArgs_Bandwidth) GetIngressRate() int32 {
	if m != nil {
		return m.IngressRate
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetIngressBurst() int32 {
	if m != nil {
		return m.IngressBurst
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetEgressRate() int32 {
	if m != nil {
		return m.EgressRate
	}
	return 0
}

func (m *CNICapArgs_Bandwidth) GetEgressBurst() int32 {
	if m != nil {
		return m.EgressBurst
	}
	return 0
}

type CNICapArgs_IPRange struct {
	Subnet     string `protobuf:"bytes,1,opt,name=subnet,proto3" json:"subnet"`
	RangeStart string `protobuf:"bytes,2,opt,name=range_start,json=rangeStart,proto3" json:"rangeStart,omitempty"`
	RangeEnd   string `protobuf:"bytes,3,opt,name=range_end,json=rangeEnd,proto3" json:"rangeEnd,omitempty"`
	Gateway    string `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
}

func (m *CNICapArgs_IPRange) Reset()      { *m = CNICapArgs_IPRange{} }
func (*CNICapArgs_IPRange) ProtoMessage() {}
func (*CNICapArgs_IPRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{0, 2}
}
func (m *CNICapArgs_IPRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_IPRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_IPRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_IPRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_IPRange.Merge(m, src)
}
func (m *CNICapArgs_IPRange) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_IPRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_IPRange.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_IPRange proto.InternalMessageInfo

func (m *CNICapArgs_IPRange) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetRangeStart() string {
	if m != nil {
		return m.RangeStart
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetRangeEnd() string {
	if m != nil {
		return m.RangeEnd
	}
	return ""
}

func (m *CNICapArgs_IPRange) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

type CNICapArgs_DNSConfig struct {
	Servers  []string `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	Searches []string `protobuf:"bytes,2,rep,name=searches,proto3" json:"searches,omitempty"`
	Options  []string `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
}

func (m *CNICapArgs_DNSConfig) Reset()      { *m = CNICapArgs_DNSConfig{} }
func (*CNICapArgs_DNSConfig) ProtoMessage() {}
func (*CNICapArgs_DNSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{0, 3}
}
func (m *CNICapArgs_DNSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNICapArgs_DNSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNICapArgs_DNSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNICapArgs_DNSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNICapArgs_DNSConfig.Merge(m, src)
}
func (m *CNICapArgs_DNSConfig) XXX_Size() int {
	return m.Size()
}
func (m *CNICapArgs_DNSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CNICapArgs_DNSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CNICapArgs_DNSConfig proto.InternalMessageInfo

func (m *CNICapArgs_DNSConfig) GetServers() []string {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *CNICapArgs_DNSConfig) GetSearches() []string {
	if m != nil {
		return m.Searches
	}
	return nil
}

func (m *CNICapArgs_DNSConfig) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

type CreateOptions struct {
	ContainerId string            `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Pid         uint32            `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	CniArgs     map[string]string `protobuf:"bytes,4,rep,name=cni_args,json=cniArgs,proto3" json:"cni_args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CapArgs     []*CNICapArgs     `protobuf:"bytes,5,rep,name=cap_args,json=capArgs,proto3" json:"cap_args,omitempty"`
}

func (m *CreateOptions) Reset()      { *m = CreateOptions{} }
func (*CreateOptions) ProtoMessage() {}
func (*CreateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{1}
}
func (m *CreateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOptions.Merge(m, src)
}
func (m *CreateOptions) XXX_Size() int {
	return m.Size()
}
func (m *CreateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOptions proto.InternalMessageInfo

func (m *CreateOptions) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *CreateOptions) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *CreateOptions) GetCniArgs() map[string]string {
	if m != nil {
		return m.CniArgs
	}
	return nil
}

func (m *CreateOptions) GetCapArgs() []*CNICapArgs {
	if m != nil {
		return m.CapArgs
	}
	return nil
}

type ConfigOptions struct {
	Ipv4Subnet string `protobuf:"bytes,1,opt,name=ipv4_subnet,json=ipv4Subnet,proto3" json:"ipv4_subnet,omitempty"`
	Ipv6Subnet string `protobuf:"bytes,2,opt,name=ipv6_subnet,json=ipv6Subnet,proto3" json:"ipv6_subnet,omitempty"`
}

func (m *ConfigOptions) Reset()      { *m = ConfigOptions{} }
func (*ConfigOptions) ProtoMessage() {}
func (*ConfigOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{2}
}
func (m *ConfigOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigOptions.Merge(m, src)
}
func (m *ConfigOptions) XXX_Size() int {
	return m.Size()
}
func (m *ConfigOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigOptions proto.InternalMessageInfo

func (m *ConfigOptions) GetIpv4Subnet() string {
	if m != nil {
		return m.Ipv4Subnet
	}
	return ""
}

func (m *ConfigOptions) GetIpv6Subnet() string {
	if m != nil {
		return m.Ipv6Subnet
	}
	return ""
}

type GetAddrOptions struct {
	Pid uint32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *GetAddrOptions) Reset()      { *m = GetAddrOptions{} }
func (*GetAddrOptions) ProtoMessage() {}
func (*GetAddrOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{3}
}
func (m *GetAddrOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAddrOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAddrOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAddrOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAddrOptions.Merge(m, src)
}
func (m *GetAddrOptions) XXX_Size() int {
	return m.Size()
}
func (m *GetAddrOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAddrOptions.DiscardUnknown(m)
}

var xxx_messageInfo_GetAddrOptions proto.InternalMessageInfo

func (m *GetAddrOptions) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type UpdateLinkOptions struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Pid         uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Ipv4PodCidr string `protobuf:"bytes,3,opt,name=ipv4_pod_cidr,json=ipv4PodCidr,proto3" json:"ipv4_pod_cidr,omitempty"`
	Ipv6PodCidr string `protobuf:"bytes,4,opt,name=ipv6_pod_cidr,json=ipv6PodCidr,proto3" json:"ipv6_pod_cidr,omitempty"`
}

func (m *UpdateLinkOptions) Reset()      { *m = UpdateLinkOptions{} }
func (*UpdateLinkOptions) ProtoMessage() {}
func (*UpdateLinkOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{4}
}
func (m *UpdateLinkOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLinkOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLinkOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLinkOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLinkOptions.Merge(m, src)
}
func (m *UpdateLinkOptions) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLinkOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLinkOptions.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLinkOptions proto.InternalMessageInfo

func (m *UpdateLinkOptions) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *UpdateLinkOptions) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *UpdateLinkOptions) GetIpv4PodCidr() string {
	if m != nil {
		return m.Ipv4PodCidr
	}
	return ""
}

func (m *UpdateLinkOptions) GetIpv6PodCidr() string {
	if m != nil {
		return m.Ipv6PodCidr
	}
	return ""
}

type RestoreLinkOptions struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Pid         uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *RestoreLinkOptions) Reset()      { *m = RestoreLinkOptions{} }
func (*RestoreLinkOptions) ProtoMessage() {}
func (*RestoreLinkOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{5}
}
func (m *RestoreLinkOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestoreLinkOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestoreLinkOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestoreLinkOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestoreLinkOptions.Merge(m, src)
}
func (m *RestoreLinkOptions) XXX_Size() int {
	return m.Size()
}
func (m *RestoreLinkOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RestoreLinkOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RestoreLinkOptions proto.InternalMessageInfo

func (m *RestoreLinkOptions) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *RestoreLinkOptions) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type DeleteLinkOptions struct {
	ContainerId string `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	Pid         uint32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
}

func (m *DeleteLinkOptions) Reset()      { *m = DeleteLinkOptions{} }
func (*DeleteLinkOptions) ProtoMessage() {}
func (*DeleteLinkOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{6}
}
func (m *DeleteLinkOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteLinkOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteLinkOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteLinkOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteLinkOptions.Merge(m, src)
}
func (m *DeleteLinkOptions) XXX_Size() int {
	return m.Size()
}
func (m *DeleteLinkOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteLinkOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteLinkOptions proto.InternalMessageInfo

func (m *DeleteLinkOptions) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *DeleteLinkOptions) GetPid() uint32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type Request struct {
	Action Request_ActionType `protobuf:"varint,1,opt,name=action,proto3,enum=abbot.Request_ActionType" json:"action,omitempty"`
	// Types that are valid to be assigned to Option:
	//	*Request_CreateOpts
	//	*Request_ConfigOpts
	//	*Request_GetAddrOpts
	//	*Request_UpdateLinkOpts
	//	*Request_RestoreLinkOpts
	//	*Request_DeleteLinkOpts
	Option isRequest_Option `protobuf_oneof:"option"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{7}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type isRequest_Option interface {
	isRequest_Option()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Request_CreateOpts struct {
	CreateOpts *CreateOptions `protobuf:"bytes,2,opt,name=create_opts,json=createOpts,proto3,oneof" json:"create_opts,omitempty"`
}
type Request_ConfigOpts struct {
	ConfigOpts *ConfigOptions `protobuf:"bytes,3,opt,name=config_opts,json=configOpts,proto3,oneof" json:"config_opts,omitempty"`
}
type Request_GetAddrOpts struct {
	GetAddrOpts *GetAddrOptions `protobuf:"bytes,4,opt,name=get_addr_opts,json=getAddrOpts,proto3,oneof" json:"get_addr_opts,omitempty"`
}
type Request_UpdateLinkOpts struct {
	UpdateLinkOpts *UpdateLinkOptions `protobuf:"bytes,5,opt,name=update_link_opts,json=updateLinkOpts,proto3,oneof" json:"update_link_opts,omitempty"`
}
type Request_RestoreLinkOpts struct {
	RestoreLinkOpts *RestoreLinkOptions `protobuf:"bytes,6,opt,name=restore_link_opts,json=restoreLinkOpts,proto3,oneof" json:"restore_link_opts,omitempty"`
}
type Request_DeleteLinkOpts struct {
	DeleteLinkOpts *DeleteLinkOptions `protobuf:"bytes,7,opt,name=delete_link_opts,json=deleteLinkOpts,proto3,oneof" json:"delete_link_opts,omitempty"`
}

func (*Request_CreateOpts) isRequest_Option()      {}
func (*Request_ConfigOpts) isRequest_Option()      {}
func (*Request_GetAddrOpts) isRequest_Option()     {}
func (*Request_UpdateLinkOpts) isRequest_Option()  {}
func (*Request_RestoreLinkOpts) isRequest_Option() {}
func (*Request_DeleteLinkOpts) isRequest_Option()  {}

func (m *Request) GetOption() isRequest_Option {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *Request) GetAction() Request_ActionType {
	if m != nil {
		return m.Action
	}
	return _invalid
}

func (m *Request) GetCreateOpts() *CreateOptions {
	if x, ok := m.GetOption().(*Request_CreateOpts); ok {
		return x.CreateOpts
	}
	return nil
}

func (m *Request) GetConfigOpts() *ConfigOptions {
	if x, ok := m.GetOption().(*Request_ConfigOpts); ok {
		return x.ConfigOpts
	}
	return nil
}

func (m *Request) GetGetAddrOpts() *GetAddrOptions {
	if x, ok := m.GetOption().(*Request_GetAddrOpts); ok {
		return x.GetAddrOpts
	}
	return nil
}

func (m *Request) GetUpdateLinkOpts() *UpdateLinkOptions {
	if x, ok := m.GetOption().(*Request_UpdateLinkOpts); ok {
		return x.UpdateLinkOpts
	}
	return nil
}

func (m *Request) GetRestoreLinkOpts() *RestoreLinkOptions {
	if x, ok := m.GetOption().(*Request_RestoreLinkOpts); ok {
		return x.RestoreLinkOpts
	}
	return nil
}

func (m *Request) GetDeleteLinkOpts() *DeleteLinkOptions {
	if x, ok := m.GetOption().(*Request_DeleteLinkOpts); ok {
		return x.DeleteLinkOpts
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Request_CreateOpts)(nil),
		(*Request_ConfigOpts)(nil),
		(*Request_GetAddrOpts)(nil),
		(*Request_UpdateLinkOpts)(nil),
		(*Request_RestoreLinkOpts)(nil),
		(*Request_DeleteLinkOpts)(nil),
	}
}

type Response struct {
	// Types that are valid to be assigned to Resp:
	//	*Response_AddrResp
	//	*Response_EmptyResp
	Resp isResponse_Resp `protobuf_oneof:"resp"`
}

func (m *Response) Reset()      { *m = Response{} }
func (*Response) ProtoMessage() {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{8}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type isResponse_Resp interface {
	isResponse_Resp()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Response_AddrResp struct {
	AddrResp *AddressResponse `protobuf:"bytes,6,opt,name=addr_resp,json=addrResp,proto3,oneof" json:"addr_resp,omitempty"`
}
type Response_EmptyResp struct {
	EmptyResp *EmptyResponse `protobuf:"bytes,7,opt,name=empty_resp,json=emptyResp,proto3,oneof" json:"empty_resp,omitempty"`
}

func (*Response_AddrResp) isResponse_Resp()  {}
func (*Response_EmptyResp) isResponse_Resp() {}

func (m *Response) GetResp() isResponse_Resp {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *Response) GetAddrResp() *AddressResponse {
	if x, ok := m.GetResp().(*Response_AddrResp); ok {
		return x.AddrResp
	}
	return nil
}

func (m *Response) GetEmptyResp() *EmptyResponse {
	if x, ok := m.GetResp().(*Response_EmptyResp); ok {
		return x.EmptyResp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Response) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Response_AddrResp)(nil),
		(*Response_EmptyResp)(nil),
	}
}

type AddressResponse struct {
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *AddressResponse) Reset()      { *m = AddressResponse{} }
func (*AddressResponse) ProtoMessage() {}
func (*AddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{9}
}
func (m *AddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressResponse.Merge(m, src)
}
func (m *AddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddressResponse proto.InternalMessageInfo

func (m *AddressResponse) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()      { *m = EmptyResponse{} }
func (*EmptyResponse) ProtoMessage() {}
func (*EmptyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b2b25f2ac9fc4575, []int{10}
}
func (m *EmptyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmptyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyResponse.Merge(m, src)
}
func (m *EmptyResponse) XXX_Size() int {
	return m.Size()
}
func (m *EmptyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("abbot.Request_ActionType", Request_ActionType_name, Request_ActionType_value)
	proto.RegisterType((*CNICapArgs)(nil), "abbot.CNICapArgs")
	proto.RegisterType((*CNICapArgs_PortMap)(nil), "abbot.CNICapArgs.PortMap")
	proto.RegisterType((*CNICapArgs_Bandwidth)(nil), "abbot.CNICapArgs.Bandwidth")
	proto.RegisterType((*CNICapArgs_IPRange)(nil), "abbot.CNICapArgs.IPRange")
	proto.RegisterType((*CNICapArgs_DNSConfig)(nil), "abbot.CNICapArgs.DNSConfig")
	proto.RegisterType((*CreateOptions)(nil), "abbot.CreateOptions")
	proto.RegisterMapType((map[string]string)(nil), "abbot.CreateOptions.CniArgsEntry")
	proto.RegisterType((*ConfigOptions)(nil), "abbot.ConfigOptions")
	proto.RegisterType((*GetAddrOptions)(nil), "abbot.GetAddrOptions")
	proto.RegisterType((*UpdateLinkOptions)(nil), "abbot.UpdateLinkOptions")
	proto.RegisterType((*RestoreLinkOptions)(nil), "abbot.RestoreLinkOptions")
	proto.RegisterType((*DeleteLinkOptions)(nil), "abbot.DeleteLinkOptions")
	proto.RegisterType((*Request)(nil), "abbot.Request")
	proto.RegisterType((*Response)(nil), "abbot.Response")
	proto.RegisterType((*AddressResponse)(nil), "abbot.AddressResponse")
	proto.RegisterType((*EmptyResponse)(nil), "abbot.EmptyResponse")
}

func init() { proto.RegisterFile("cni.proto", fileDescriptor_b2b25f2ac9fc4575) }

var fileDescriptor_b2b25f2ac9fc4575 = []byte{
	// 1258 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x26, 0x25, 0x59, 0x97, 0xa3, 0x8b, 0xa5, 0x41, 0x12, 0x28, 0xfa, 0x01, 0x2a, 0xe1, 0xbf,
	0xc9, 0xff, 0x23, 0x91, 0x51, 0x27, 0x71, 0xd3, 0x34, 0x41, 0xa1, 0x5b, 0x2d, 0xa1, 0x89, 0xe3,
	0x8e, 0x9d, 0x4d, 0x37, 0x04, 0x45, 0x4e, 0x68, 0xc2, 0x36, 0xc9, 0xce, 0x50, 0x0a, 0xbc, 0x0b,
	0xd0, 0x17, 0xc8, 0x2b, 0x74, 0xd7, 0x97, 0xe8, 0xa6, 0xab, 0xae, 0x8a, 0x2c, 0xb3, 0x12, 0x1a,
	0x65, 0x53, 0x08, 0x5d, 0xe4, 0x11, 0x8a, 0xb9, 0x50, 0xa2, 0xea, 0x64, 0x95, 0x95, 0xce, 0x7c,
	0xf3, 0x7d, 0x67, 0xbe, 0x99, 0x73, 0x38, 0x23, 0x28, 0x39, 0x81, 0xdf, 0x89, 0x68, 0x18, 0x87,
	0x68, 0xcb, 0x9e, 0x4c, 0xc2, 0xb8, 0x75, 0xc7, 0xf3, 0xe3, 0x93, 0xe9, 0xa4, 0xe3, 0x84, 0xe7,
	0x3b, 0x5e, 0xe8, 0x85, 0x3b, 0x62, 0x76, 0x32, 0x7d, 0x21, 0x46, 0x62, 0x20, 0x22, 0xa9, 0x32,
	0xdf, 0x16, 0x01, 0xfa, 0x07, 0xe3, 0xbe, 0x1d, 0x75, 0xa9, 0xc7, 0xd0, 0x63, 0xa8, 0x44, 0x21,
	0x8d, 0xad, 0x73, 0x3b, 0xb2, 0x6c, 0xea, 0x35, 0xf5, 0x1b, 0xfa, 0xad, 0xf2, 0xee, 0xf5, 0x8e,
	0xc8, 0xdd, 0x59, 0x13, 0x3b, 0x87, 0x21, 0x8d, 0x9f, 0xda, 0xd1, 0x48, 0xc3, 0x10, 0xc9, 0xb0,
	0x4b, 0x3d, 0xd4, 0x83, 0xea, 0xc4, 0x0e, 0xdc, 0x97, 0xbe, 0x1b, 0x9f, 0x08, 0x7d, 0x46, 0xe8,
	0xff, 0x73, 0x59, 0xdf, 0x4b, 0x68, 0x23, 0x0d, 0x57, 0x56, 0x1a, 0x9e, 0xe3, 0x31, 0x54, 0xfc,
	0xc8, 0xa2, 0x76, 0xe0, 0x11, 0x91, 0x22, 0xfb, 0x29, 0x0b, 0xe3, 0x43, 0xcc, 0x49, 0xdc, 0x82,
	0x1f, 0x89, 0x90, 0xcb, 0xfb, 0x50, 0x73, 0x03, 0x66, 0x39, 0x61, 0xf0, 0xc2, 0xf7, 0x44, 0x82,
	0xdc, 0xa7, 0x3c, 0x0c, 0x0e, 0x8e, 0xfa, 0x82, 0xc6, 0x3d, 0xb8, 0x01, 0x93, 0x83, 0x2e, 0xf5,
	0x5a, 0xbf, 0xea, 0x50, 0x50, 0x3b, 0x44, 0x0f, 0xa0, 0xe6, 0x84, 0x41, 0x6c, 0xfb, 0x01, 0xa1,
	0x16, 0xdf, 0xab, 0x38, 0x94, 0xad, 0x5e, 0x63, 0x39, 0x6f, 0x57, 0x57, 0x33, 0x9c, 0x8d, 0x37,
	0x87, 0xe8, 0x7f, 0x50, 0x3a, 0x09, 0x59, 0x2c, 0x45, 0x19, 0x21, 0xaa, 0x2c, 0xe7, 0xed, 0x22,
	0x07, 0x05, 0x7f, 0x15, 0xa1, 0x5b, 0x50, 0x14, 0xf5, 0x70, 0xc2, 0x33, 0xb1, 0xe1, 0x92, 0x64,
	0x26, 0x18, 0x5e, 0x45, 0xe8, 0xbf, 0x50, 0x10, 0x49, 0xfd, 0x48, 0x6c, 0xac, 0xd4, 0x83, 0xe5,
	0xbc, 0x9d, 0xe7, 0xd0, 0xf8, 0x10, 0xcb, 0xdf, 0xa8, 0xf5, 0x53, 0x06, 0x4a, 0xab, 0x13, 0x46,
	0x8f, 0xa0, 0xe2, 0x07, 0x1e, 0x25, 0x8c, 0x59, 0xd4, 0x8e, 0x89, 0xf2, 0x7f, 0x7d, 0x39, 0x6f,
	0x5f, 0x55, 0x38, 0xb6, 0x63, 0x72, 0x3b, 0x3c, 0xf7, 0x63, 0x72, 0x1e, 0xc5, 0x17, 0xb8, 0x9c,
	0x82, 0xd1, 0x37, 0x50, 0x4d, 0xd4, 0x93, 0x29, 0x65, 0xc9, 0x4e, 0x5a, 0xcb, 0x79, 0xfb, 0x9a,
	0x9a, 0xe8, 0x71, 0x3c, 0xa5, 0xaf, 0xa4, 0x71, 0xf4, 0x15, 0x94, 0x49, 0x6a, 0xf5, 0xac, 0x90,
	0x37, 0x97, 0xf3, 0xf6, 0x15, 0xf2, 0xb1, 0xc5, 0x61, 0x8d, 0x72, 0xe7, 0x24, 0xbd, 0x74, 0x6e,
	0xed, 0x9c, 0x7c, 0x74, 0xe5, 0x72, 0x0a, 0x6e, 0xfd, 0xa1, 0x43, 0x41, 0x35, 0x09, 0x32, 0x21,
	0xcf, 0xa6, 0x93, 0x80, 0xc8, 0xea, 0xa9, 0x53, 0x93, 0x08, 0x56, 0xbf, 0xdc, 0xa8, 0x6c, 0x3b,
	0x16, 0xdb, 0xaa, 0x62, 0x25, 0x69, 0x54, 0xc0, 0x47, 0x1c, 0x4d, 0x1b, 0x5d, 0xa3, 0xe8, 0x2e,
	0x94, 0xa4, 0x94, 0x04, 0xae, 0x2a, 0xe0, 0xb5, 0xe5, 0xbc, 0x8d, 0x04, 0x38, 0x0c, 0xdc, 0x94,
	0xac, 0x98, 0x60, 0x68, 0x07, 0x0a, 0x9e, 0x1d, 0x93, 0x97, 0xf6, 0x85, 0x2a, 0xe5, 0xd5, 0xe5,
	0xbc, 0xdd, 0x50, 0x50, 0x4a, 0x91, 0xb0, 0x5a, 0x3f, 0xeb, 0x50, 0x5a, 0x35, 0x2d, 0x97, 0x33,
	0x42, 0x67, 0x84, 0xb2, 0xa6, 0x7e, 0x23, 0x9b, 0xc8, 0x15, 0x94, 0x96, 0x2b, 0x08, 0xed, 0x42,
	0x91, 0x11, 0x9b, 0x3a, 0x27, 0x84, 0x35, 0x33, 0x42, 0x21, 0x3c, 0x26, 0x58, 0xda, 0x63, 0x82,
	0xf1, 0x45, 0xc2, 0x28, 0xf6, 0xc3, 0x80, 0x35, 0xb3, 0xeb, 0x45, 0x14, 0x94, 0x5e, 0x44, 0x41,
	0xbd, 0x22, 0xe4, 0x65, 0x68, 0xfe, 0xad, 0x43, 0xb5, 0x4f, 0x89, 0x1d, 0x93, 0x67, 0x72, 0x0e,
	0xdd, 0x84, 0xca, 0xfa, 0x53, 0xf2, 0x5d, 0x59, 0x0a, 0x5c, 0x5e, 0x61, 0x63, 0x17, 0xd5, 0x21,
	0x1b, 0xf9, 0xae, 0x38, 0xfb, 0x2a, 0xe6, 0x21, 0x7a, 0x04, 0x45, 0x27, 0xf0, 0xf9, 0x97, 0xcc,
	0x9a, 0xb9, 0x1b, 0xd9, 0x5b, 0xe5, 0xdd, 0x9b, 0xc9, 0xa7, 0x9c, 0x4e, 0xde, 0xe9, 0x07, 0x3e,
	0xff, 0xaa, 0x87, 0x41, 0x4c, 0x2f, 0x70, 0xc1, 0x91, 0x23, 0x74, 0x1b, 0x8a, 0x8e, 0xbc, 0xcb,
	0x58, 0x73, 0x4b, 0xa8, 0x1b, 0x97, 0x2e, 0x02, 0x5c, 0x70, 0x64, 0xd0, 0x7a, 0x08, 0x95, 0x74,
	0x1a, 0xee, 0xe6, 0x94, 0x5c, 0x28, 0x9f, 0x3c, 0x44, 0x57, 0x60, 0x6b, 0x66, 0x9f, 0x4d, 0x89,
	0xec, 0x0e, 0x2c, 0x07, 0x0f, 0x33, 0x0f, 0x74, 0xf3, 0x7b, 0xa8, 0xca, 0xc2, 0x24, 0xbb, 0x6d,
	0x43, 0xd9, 0x8f, 0x66, 0xf7, 0xac, 0x74, 0xdf, 0xf1, 0xab, 0x6a, 0x76, 0xef, 0x48, 0xf6, 0x9b,
	0x24, 0xec, 0x25, 0x84, 0xcc, 0x8a, 0xb0, 0x27, 0x09, 0xa6, 0x09, 0xb5, 0x7d, 0x12, 0x77, 0x5d,
	0x97, 0x26, 0x39, 0xd5, 0xf1, 0xe8, 0xab, 0xe3, 0x31, 0x5f, 0xeb, 0xd0, 0x78, 0x1e, 0xb9, 0x76,
	0x4c, 0x9e, 0xf8, 0xc1, 0xe9, 0x67, 0x9d, 0xb4, 0x09, 0x55, 0x61, 0x38, 0x0a, 0x5d, 0xcb, 0xf1,
	0x5d, 0x2a, 0x1b, 0x19, 0x8b, 0x5d, 0x1c, 0x86, 0x6e, 0xdf, 0x77, 0xa9, 0xe2, 0xec, 0xad, 0x39,
	0xb9, 0x15, 0x67, 0x4f, 0x71, 0xcc, 0x31, 0x20, 0x4c, 0x58, 0x1c, 0xd2, 0xcf, 0xb6, 0x64, 0x8e,
	0xa0, 0x31, 0x20, 0x67, 0xe4, 0xf3, 0x37, 0x67, 0xfe, 0x96, 0x83, 0x02, 0x26, 0x3f, 0x4e, 0x09,
	0x8b, 0xd1, 0x17, 0x90, 0xb7, 0x1d, 0x9e, 0x4b, 0x48, 0x6b, 0xab, 0xc7, 0x45, 0xcd, 0x77, 0xba,
	0x62, 0xf2, 0xf8, 0x22, 0x22, 0x58, 0x11, 0xd1, 0x97, 0x50, 0x76, 0x44, 0xbb, 0x59, 0x61, 0x14,
	0x33, 0xf5, 0xae, 0x5d, 0xf9, 0x58, 0x23, 0xf2, 0xf7, 0xc8, 0x49, 0x00, 0x26, 0x84, 0xf2, 0x2d,
	0x12, 0xc2, 0xec, 0xa6, 0x30, 0xdd, 0x30, 0x42, 0x98, 0x00, 0x0c, 0x7d, 0x0d, 0x55, 0x8f, 0xc4,
	0x96, 0xed, 0xba, 0x54, 0x4a, 0xe5, 0x3b, 0x76, 0x55, 0x49, 0x37, 0x1b, 0x63, 0xa4, 0xe1, 0xb2,
	0xb7, 0x42, 0x18, 0x1a, 0x40, 0x7d, 0x2a, 0x9a, 0xc2, 0x3a, 0xf3, 0x83, 0x53, 0xa9, 0xdf, 0x12,
	0xfa, 0xa6, 0xd2, 0x5f, 0xea, 0x99, 0x91, 0x86, 0x6b, 0xd3, 0x34, 0xc8, 0xd0, 0x3e, 0x34, 0xa8,
	0x2c, 0x64, 0x2a, 0x4d, 0x7e, 0xe3, 0x3d, 0xbe, 0x5c, 0xe8, 0x91, 0x86, 0xb7, 0xe9, 0x06, 0x2a,
	0xec, 0xb8, 0xa2, 0x8c, 0xa9, 0x3c, 0x85, 0x0d, 0x3b, 0x97, 0xaa, 0xcc, 0xed, 0xb8, 0x69, 0x90,
	0x99, 0x33, 0x80, 0x75, 0x65, 0x50, 0x05, 0x8a, 0x96, 0x1f, 0xcc, 0xec, 0x33, 0xdf, 0xad, 0x6b,
	0x08, 0x20, 0xdf, 0xc7, 0xc3, 0xee, 0xf1, 0xb0, 0xae, 0xf3, 0x78, 0x30, 0x7c, 0x32, 0x3c, 0x1e,
	0xd6, 0x33, 0xa8, 0x01, 0xd5, 0xe7, 0x87, 0x83, 0xee, 0xf1, 0xd0, 0xea, 0x3f, 0x3b, 0xf8, 0x76,
	0xbc, 0x5f, 0xcf, 0x72, 0xe1, 0xfe, 0xf0, 0xd8, 0xea, 0x0e, 0x06, 0xb8, 0x9e, 0x43, 0xdb, 0x50,
	0x56, 0x84, 0x27, 0xe3, 0x83, 0xef, 0xea, 0x5b, 0xa8, 0x0e, 0x15, 0x3c, 0x3c, 0x3a, 0x7e, 0x86,
	0x15, 0x92, 0x4f, 0x5d, 0x69, 0xaf, 0x74, 0x28, 0x62, 0xc2, 0xa2, 0x30, 0x60, 0x04, 0xdd, 0x87,
	0x92, 0x28, 0x0e, 0x25, 0x2c, 0x52, 0xa7, 0x72, 0x4d, 0xed, 0x86, 0xd7, 0x81, 0xbf, 0x61, 0x8a,
	0x3a, 0xd2, 0x70, 0x91, 0x53, 0xf9, 0x18, 0xdd, 0x07, 0x10, 0x57, 0xa6, 0xd4, 0x15, 0x36, 0xfa,
	0x61, 0x28, 0xee, 0xd2, 0xb5, 0xaa, 0x44, 0x12, 0xa0, 0x97, 0x87, 0x1c, 0x17, 0x98, 0x37, 0x61,
	0xfb, 0x5f, 0xd9, 0x51, 0x0d, 0x32, 0x7e, 0xa4, 0xbe, 0x82, 0x8c, 0x1f, 0x99, 0xdb, 0x50, 0xdd,
	0x48, 0xb4, 0xfb, 0x08, 0x6a, 0x07, 0x24, 0x7e, 0x19, 0xd2, 0xd3, 0xa7, 0x76, 0x60, 0x7b, 0x84,
	0xa2, 0xff, 0x43, 0xe1, 0x90, 0x86, 0x0e, 0x61, 0x0c, 0xd5, 0x36, 0x9b, 0xbf, 0xb5, 0xbd, 0xae,
	0xac, 0x50, 0xf7, 0x9e, 0xbf, 0x79, 0x67, 0x68, 0x6f, 0xdf, 0x19, 0xda, 0x87, 0x77, 0x86, 0xfe,
	0x6a, 0x61, 0xe8, 0xbf, 0x2c, 0x0c, 0xfd, 0xf7, 0x85, 0xa1, 0xbf, 0x59, 0x18, 0xfa, 0x9f, 0x0b,
	0x43, 0xff, 0x6b, 0x61, 0x68, 0x1f, 0x16, 0x86, 0xfe, 0xfa, 0xbd, 0xa1, 0xbd, 0x79, 0x6f, 0x68,
	0x6f, 0xdf, 0x1b, 0xda, 0x0f, 0x6d, 0x9b, 0x9e, 0xd8, 0x71, 0xc7, 0x25, 0xb3, 0x1d, 0x91, 0xef,
	0x8e, 0xfc, 0xeb, 0x29, 0x62, 0x2f, 0x8c, 0x26, 0x93, 0xbc, 0x00, 0xee, 0xfe, 0x13, 0x00, 0x00,
	0xff, 0xff, 0xcb, 0x4c, 0x05, 0xfb, 0xc3, 0x0a, 0x00, 0x00,
}

func (x Request_ActionType) String() string {
	s, ok := Request_ActionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CNICapArgs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs)
	if !ok {
		that2, ok := that.(CNICapArgs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Option == nil {
		if this.Option != nil {
			return false
		}
	} else if this.Option == nil {
		return false
	} else if !this.Option.Equal(that1.Option) {
		return false
	}
	return true
}
func (this *CNICapArgs_PortMapArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_PortMapArg)
	if !ok {
		that2, ok := that.(CNICapArgs_PortMapArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PortMapArg.Equal(that1.PortMapArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_BandwidthArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_BandwidthArg)
	if !ok {
		that2, ok := that.(CNICapArgs_BandwidthArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BandwidthArg.Equal(that1.BandwidthArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_IpRangeArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IpRangeArg)
	if !ok {
		that2, ok := that.(CNICapArgs_IpRangeArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpRangeArg.Equal(that1.IpRangeArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_DnsConfigArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DnsConfigArg)
	if !ok {
		that2, ok := that.(CNICapArgs_DnsConfigArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DnsConfigArg.Equal(that1.DnsConfigArg) {
		return false
	}
	return true
}
func (this *CNICapArgs_PortMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_PortMap)
	if !ok {
		that2, ok := that.(CNICapArgs_PortMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.HostIp != that1.HostIp {
		return false
	}
	return true
}
func (this *CNICapArgs_Bandwidth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_Bandwidth)
	if !ok {
		that2, ok := that.(CNICapArgs_Bandwidth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IngressRate != that1.IngressRate {
		return false
	}
	if this.IngressBurst != that1.IngressBurst {
		return false
	}
	if this.EgressRate != that1.EgressRate {
		return false
	}
	if this.EgressBurst != that1.EgressBurst {
		return false
	}
	return true
}
func (this *CNICapArgs_IPRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_IPRange)
	if !ok {
		that2, ok := that.(CNICapArgs_IPRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Subnet != that1.Subnet {
		return false
	}
	if this.RangeStart != that1.RangeStart {
		return false
	}
	if this.RangeEnd != that1.RangeEnd {
		return false
	}
	if this.Gateway != that1.Gateway {
		return false
	}
	return true
}
func (this *CNICapArgs_DNSConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CNICapArgs_DNSConfig)
	if !ok {
		that2, ok := that.(CNICapArgs_DNSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Servers) != len(that1.Servers) {
		return false
	}
	for i := range this.Servers {
		if this.Servers[i] != that1.Servers[i] {
			return false
		}
	}
	if len(this.Searches) != len(that1.Searches) {
		return false
	}
	for i := range this.Searches {
		if this.Searches[i] != that1.Searches[i] {
			return false
		}
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateOptions)
	if !ok {
		that2, ok := that.(CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if len(this.CniArgs) != len(that1.CniArgs) {
		return false
	}
	for i := range this.CniArgs {
		if this.CniArgs[i] != that1.CniArgs[i] {
			return false
		}
	}
	if len(this.CapArgs) != len(that1.CapArgs) {
		return false
	}
	for i := range this.CapArgs {
		if !this.CapArgs[i].Equal(that1.CapArgs[i]) {
			return false
		}
	}
	return true
}
func (this *ConfigOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigOptions)
	if !ok {
		that2, ok := that.(ConfigOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4Subnet != that1.Ipv4Subnet {
		return false
	}
	if this.Ipv6Subnet != that1.Ipv6Subnet {
		return false
	}
	return true
}
func (this *GetAddrOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAddrOptions)
	if !ok {
		that2, ok := that.(GetAddrOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *UpdateLinkOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateLinkOptions)
	if !ok {
		that2, ok := that.(UpdateLinkOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Ipv4PodCidr != that1.Ipv4PodCidr {
		return false
	}
	if this.Ipv6PodCidr != that1.Ipv6PodCidr {
		return false
	}
	return true
}
func (this *RestoreLinkOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestoreLinkOptions)
	if !ok {
		that2, ok := that.(RestoreLinkOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *DeleteLinkOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteLinkOptions)
	if !ok {
		that2, ok := that.(DeleteLinkOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainerId != that1.ContainerId {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.Option == nil {
		if this.Option != nil {
			return false
		}
	} else if this.Option == nil {
		return false
	} else if !this.Option.Equal(that1.Option) {
		return false
	}
	return true
}
func (this *Request_CreateOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_CreateOpts)
	if !ok {
		that2, ok := that.(Request_CreateOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateOpts.Equal(that1.CreateOpts) {
		return false
	}
	return true
}
func (this *Request_ConfigOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_ConfigOpts)
	if !ok {
		that2, ok := that.(Request_ConfigOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConfigOpts.Equal(that1.ConfigOpts) {
		return false
	}
	return true
}
func (this *Request_GetAddrOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_GetAddrOpts)
	if !ok {
		that2, ok := that.(Request_GetAddrOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetAddrOpts.Equal(that1.GetAddrOpts) {
		return false
	}
	return true
}
func (this *Request_UpdateLinkOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_UpdateLinkOpts)
	if !ok {
		that2, ok := that.(Request_UpdateLinkOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UpdateLinkOpts.Equal(that1.UpdateLinkOpts) {
		return false
	}
	return true
}
func (this *Request_RestoreLinkOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_RestoreLinkOpts)
	if !ok {
		that2, ok := that.(Request_RestoreLinkOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RestoreLinkOpts.Equal(that1.RestoreLinkOpts) {
		return false
	}
	return true
}
func (this *Request_DeleteLinkOpts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request_DeleteLinkOpts)
	if !ok {
		that2, ok := that.(Request_DeleteLinkOpts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteLinkOpts.Equal(that1.DeleteLinkOpts) {
		return false
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Resp == nil {
		if this.Resp != nil {
			return false
		}
	} else if this.Resp == nil {
		return false
	} else if !this.Resp.Equal(that1.Resp) {
		return false
	}
	return true
}
func (this *Response_AddrResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response_AddrResp)
	if !ok {
		that2, ok := that.(Response_AddrResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddrResp.Equal(that1.AddrResp) {
		return false
	}
	return true
}
func (this *Response_EmptyResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response_EmptyResp)
	if !ok {
		that2, ok := that.(Response_EmptyResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EmptyResp.Equal(that1.EmptyResp) {
		return false
	}
	return true
}
func (this *AddressResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddressResponse)
	if !ok {
		that2, ok := that.(AddressResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *EmptyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmptyResponse)
	if !ok {
		that2, ok := that.(EmptyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *CNICapArgs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs{")
	if this.Option != nil {
		s = append(s, "Option: "+fmt.Sprintf("%#v", this.Option)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_PortMapArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_PortMapArg{` +
		`PortMapArg:` + fmt.Sprintf("%#v", this.PortMapArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_BandwidthArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_BandwidthArg{` +
		`BandwidthArg:` + fmt.Sprintf("%#v", this.BandwidthArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_IpRangeArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_IpRangeArg{` +
		`IpRangeArg:` + fmt.Sprintf("%#v", this.IpRangeArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_DnsConfigArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.CNICapArgs_DnsConfigArg{` +
		`DnsConfigArg:` + fmt.Sprintf("%#v", this.DnsConfigArg) + `}`}, ", ")
	return s
}
func (this *CNICapArgs_PortMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_PortMap{")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "HostIp: "+fmt.Sprintf("%#v", this.HostIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_Bandwidth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_Bandwidth{")
	s = append(s, "IngressRate: "+fmt.Sprintf("%#v", this.IngressRate)+",\n")
	s = append(s, "IngressBurst: "+fmt.Sprintf("%#v", this.IngressBurst)+",\n")
	s = append(s, "EgressRate: "+fmt.Sprintf("%#v", this.EgressRate)+",\n")
	s = append(s, "EgressBurst: "+fmt.Sprintf("%#v", this.EgressBurst)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_IPRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CNICapArgs_IPRange{")
	s = append(s, "Subnet: "+fmt.Sprintf("%#v", this.Subnet)+",\n")
	s = append(s, "RangeStart: "+fmt.Sprintf("%#v", this.RangeStart)+",\n")
	s = append(s, "RangeEnd: "+fmt.Sprintf("%#v", this.RangeEnd)+",\n")
	s = append(s, "Gateway: "+fmt.Sprintf("%#v", this.Gateway)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CNICapArgs_DNSConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&abbotgopb.CNICapArgs_DNSConfig{")
	s = append(s, "Servers: "+fmt.Sprintf("%#v", this.Servers)+",\n")
	s = append(s, "Searches: "+fmt.Sprintf("%#v", this.Searches)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.CreateOptions{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	keysForCniArgs := make([]string, 0, len(this.CniArgs))
	for k, _ := range this.CniArgs {
		keysForCniArgs = append(keysForCniArgs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCniArgs)
	mapStringForCniArgs := "map[string]string{"
	for _, k := range keysForCniArgs {
		mapStringForCniArgs += fmt.Sprintf("%#v: %#v,", k, this.CniArgs[k])
	}
	mapStringForCniArgs += "}"
	if this.CniArgs != nil {
		s = append(s, "CniArgs: "+mapStringForCniArgs+",\n")
	}
	if this.CapArgs != nil {
		s = append(s, "CapArgs: "+fmt.Sprintf("%#v", this.CapArgs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.ConfigOptions{")
	s = append(s, "Ipv4Subnet: "+fmt.Sprintf("%#v", this.Ipv4Subnet)+",\n")
	s = append(s, "Ipv6Subnet: "+fmt.Sprintf("%#v", this.Ipv6Subnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAddrOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.GetAddrOptions{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateLinkOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&abbotgopb.UpdateLinkOptions{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Ipv4PodCidr: "+fmt.Sprintf("%#v", this.Ipv4PodCidr)+",\n")
	s = append(s, "Ipv6PodCidr: "+fmt.Sprintf("%#v", this.Ipv6PodCidr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestoreLinkOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.RestoreLinkOptions{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteLinkOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.DeleteLinkOptions{")
	s = append(s, "ContainerId: "+fmt.Sprintf("%#v", this.ContainerId)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&abbotgopb.Request{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.Option != nil {
		s = append(s, "Option: "+fmt.Sprintf("%#v", this.Option)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request_CreateOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_CreateOpts{` +
		`CreateOpts:` + fmt.Sprintf("%#v", this.CreateOpts) + `}`}, ", ")
	return s
}
func (this *Request_ConfigOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_ConfigOpts{` +
		`ConfigOpts:` + fmt.Sprintf("%#v", this.ConfigOpts) + `}`}, ", ")
	return s
}
func (this *Request_GetAddrOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_GetAddrOpts{` +
		`GetAddrOpts:` + fmt.Sprintf("%#v", this.GetAddrOpts) + `}`}, ", ")
	return s
}
func (this *Request_UpdateLinkOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_UpdateLinkOpts{` +
		`UpdateLinkOpts:` + fmt.Sprintf("%#v", this.UpdateLinkOpts) + `}`}, ", ")
	return s
}
func (this *Request_RestoreLinkOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_RestoreLinkOpts{` +
		`RestoreLinkOpts:` + fmt.Sprintf("%#v", this.RestoreLinkOpts) + `}`}, ", ")
	return s
}
func (this *Request_DeleteLinkOpts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Request_DeleteLinkOpts{` +
		`DeleteLinkOpts:` + fmt.Sprintf("%#v", this.DeleteLinkOpts) + `}`}, ", ")
	return s
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&abbotgopb.Response{")
	if this.Resp != nil {
		s = append(s, "Resp: "+fmt.Sprintf("%#v", this.Resp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response_AddrResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Response_AddrResp{` +
		`AddrResp:` + fmt.Sprintf("%#v", this.AddrResp) + `}`}, ", ")
	return s
}
func (this *Response_EmptyResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&abbotgopb.Response_EmptyResp{` +
		`EmptyResp:` + fmt.Sprintf("%#v", this.EmptyResp) + `}`}, ", ")
	return s
}
func (this *AddressResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&abbotgopb.AddressResponse{")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmptyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&abbotgopb.EmptyResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCni(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NetworkManagerClient is the client API for NetworkManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NetworkManagerClient interface {
	Process(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type networkManagerClient struct {
	cc *grpc.ClientConn
}

func NewNetworkManagerClient(cc *grpc.ClientConn) NetworkManagerClient {
	return &networkManagerClient{cc}
}

func (c *networkManagerClient) Process(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/abbot.NetworkManager/Process", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkManagerServer is the server API for NetworkManager service.
type NetworkManagerServer interface {
	Process(context.Context, *Request) (*Response, error)
}

// UnimplementedNetworkManagerServer can be embedded to have forward compatible implementations.
type UnimplementedNetworkManagerServer struct {
}

func (*UnimplementedNetworkManagerServer) Process(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Process not implemented")
}

func RegisterNetworkManagerServer(s *grpc.Server, srv NetworkManagerServer) {
	s.RegisterService(&_NetworkManager_serviceDesc, srv)
}

func _NetworkManager_Process_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkManagerServer).Process(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/abbot.NetworkManager/Process",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkManagerServer).Process(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "abbot.NetworkManager",
	HandlerType: (*NetworkManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Process",
			Handler:    _NetworkManager_Process_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cni.proto",
}

func (m *CNICapArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != nil {
		{
			size := m.Option.Size()
			i -= size
			if _, err := m.Option.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_PortMapArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_PortMapArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PortMapArg != nil {
		{
			size, err := m.PortMapArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_BandwidthArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_BandwidthArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BandwidthArg != nil {
		{
			size, err := m.BandwidthArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_IpRangeArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IpRangeArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpRangeArg != nil {
		{
			size, err := m.IpRangeArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_DnsConfigArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DnsConfigArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DnsConfigArg != nil {
		{
			size, err := m.DnsConfigArg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CNICapArgs_PortMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_PortMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_PortMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HostIp) > 0 {
		i -= len(m.HostIp)
		copy(dAtA[i:], m.HostIp)
		i = encodeVarintCni(dAtA, i, uint64(len(m.HostIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.HostPort != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.HostPort))
		i--
		dAtA[i] = 0x10
	}
	if m.ContainerPort != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.ContainerPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_Bandwidth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_Bandwidth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_Bandwidth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EgressBurst != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.EgressBurst))
		i--
		dAtA[i] = 0x20
	}
	if m.EgressRate != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.EgressRate))
		i--
		dAtA[i] = 0x18
	}
	if m.IngressBurst != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.IngressBurst))
		i--
		dAtA[i] = 0x10
	}
	if m.IngressRate != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.IngressRate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_IPRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_IPRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gateway) > 0 {
		i -= len(m.Gateway)
		copy(dAtA[i:], m.Gateway)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Gateway)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RangeEnd) > 0 {
		i -= len(m.RangeEnd)
		copy(dAtA[i:], m.RangeEnd)
		i = encodeVarintCni(dAtA, i, uint64(len(m.RangeEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RangeStart) > 0 {
		i -= len(m.RangeStart)
		copy(dAtA[i:], m.RangeStart)
		i = encodeVarintCni(dAtA, i, uint64(len(m.RangeStart)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subnet) > 0 {
		i -= len(m.Subnet)
		copy(dAtA[i:], m.Subnet)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNICapArgs_DNSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNICapArgs_DNSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNICapArgs_DNSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintCni(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Searches) > 0 {
		for iNdEx := len(m.Searches) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Searches[iNdEx])
			copy(dAtA[i:], m.Searches[iNdEx])
			i = encodeVarintCni(dAtA, i, uint64(len(m.Searches[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Servers[iNdEx])
			copy(dAtA[i:], m.Servers[iNdEx])
			i = encodeVarintCni(dAtA, i, uint64(len(m.Servers[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CapArgs) > 0 {
		for iNdEx := len(m.CapArgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CapArgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCni(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CniArgs) > 0 {
		for k := range m.CniArgs {
			v := m.CniArgs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintCni(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCni(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCni(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Pid != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintCni(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6Subnet) > 0 {
		i -= len(m.Ipv6Subnet)
		copy(dAtA[i:], m.Ipv6Subnet)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Ipv6Subnet)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ipv4Subnet) > 0 {
		i -= len(m.Ipv4Subnet)
		copy(dAtA[i:], m.Ipv4Subnet)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Ipv4Subnet)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAddrOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAddrOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAddrOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLinkOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLinkOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLinkOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6PodCidr) > 0 {
		i -= len(m.Ipv6PodCidr)
		copy(dAtA[i:], m.Ipv6PodCidr)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Ipv6PodCidr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ipv4PodCidr) > 0 {
		i -= len(m.Ipv4PodCidr)
		copy(dAtA[i:], m.Ipv4PodCidr)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Ipv4PodCidr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Pid != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintCni(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestoreLinkOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoreLinkOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestoreLinkOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintCni(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteLinkOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteLinkOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteLinkOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintCni(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != nil {
		{
			size := m.Option.Size()
			i -= size
			if _, err := m.Option.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Action != 0 {
		i = encodeVarintCni(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request_CreateOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_CreateOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateOpts != nil {
		{
			size, err := m.CreateOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Request_ConfigOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_ConfigOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfigOpts != nil {
		{
			size, err := m.ConfigOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Request_GetAddrOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_GetAddrOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GetAddrOpts != nil {
		{
			size, err := m.GetAddrOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Request_UpdateLinkOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_UpdateLinkOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateLinkOpts != nil {
		{
			size, err := m.UpdateLinkOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Request_RestoreLinkOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_RestoreLinkOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RestoreLinkOpts != nil {
		{
			size, err := m.RestoreLinkOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Request_DeleteLinkOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request_DeleteLinkOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteLinkOpts != nil {
		{
			size, err := m.DeleteLinkOpts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resp != nil {
		{
			size := m.Resp.Size()
			i -= size
			if _, err := m.Resp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response_AddrResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_AddrResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddrResp != nil {
		{
			size, err := m.AddrResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Response_EmptyResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response_EmptyResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EmptyResp != nil {
		{
			size, err := m.EmptyResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCni(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintCni(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EmptyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmptyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintCni(dAtA []byte, offset int, v uint64) int {
	offset -= sovCni(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CNICapArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Option != nil {
		n += m.Option.Size()
	}
	return n
}

func (m *CNICapArgs_PortMapArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortMapArg != nil {
		l = m.PortMapArg.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *CNICapArgs_BandwidthArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BandwidthArg != nil {
		l = m.BandwidthArg.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *CNICapArgs_IpRangeArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpRangeArg != nil {
		l = m.IpRangeArg.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *CNICapArgs_DnsConfigArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsConfigArg != nil {
		l = m.DnsConfigArg.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *CNICapArgs_PortMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerPort != 0 {
		n += 1 + sovCni(uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		n += 1 + sovCni(uint64(m.HostPort))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}

func (m *CNICapArgs_Bandwidth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngressRate != 0 {
		n += 1 + sovCni(uint64(m.IngressRate))
	}
	if m.IngressBurst != 0 {
		n += 1 + sovCni(uint64(m.IngressBurst))
	}
	if m.EgressRate != 0 {
		n += 1 + sovCni(uint64(m.EgressRate))
	}
	if m.EgressBurst != 0 {
		n += 1 + sovCni(uint64(m.EgressBurst))
	}
	return n
}

func (m *CNICapArgs_IPRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subnet)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.RangeStart)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.RangeEnd)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}

func (m *CNICapArgs_DNSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, s := range m.Servers {
			l = len(s)
			n += 1 + l + sovCni(uint64(l))
		}
	}
	if len(m.Searches) > 0 {
		for _, s := range m.Searches {
			l = len(s)
			n += 1 + l + sovCni(uint64(l))
		}
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovCni(uint64(l))
		}
	}
	return n
}

func (m *CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovCni(uint64(m.Pid))
	}
	if len(m.CniArgs) > 0 {
		for k, v := range m.CniArgs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCni(uint64(len(k))) + 1 + len(v) + sovCni(uint64(len(v)))
			n += mapEntrySize + 1 + sovCni(uint64(mapEntrySize))
		}
	}
	if len(m.CapArgs) > 0 {
		for _, e := range m.CapArgs {
			l = e.Size()
			n += 1 + l + sovCni(uint64(l))
		}
	}
	return n
}

func (m *ConfigOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ipv4Subnet)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.Ipv6Subnet)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}

func (m *GetAddrOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovCni(uint64(m.Pid))
	}
	return n
}

func (m *UpdateLinkOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovCni(uint64(m.Pid))
	}
	l = len(m.Ipv4PodCidr)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	l = len(m.Ipv6PodCidr)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}

func (m *RestoreLinkOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovCni(uint64(m.Pid))
	}
	return n
}

func (m *DeleteLinkOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	if m.Pid != 0 {
		n += 1 + sovCni(uint64(m.Pid))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCni(uint64(m.Action))
	}
	if m.Option != nil {
		n += m.Option.Size()
	}
	return n
}

func (m *Request_CreateOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateOpts != nil {
		l = m.CreateOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Request_ConfigOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigOpts != nil {
		l = m.ConfigOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Request_GetAddrOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAddrOpts != nil {
		l = m.GetAddrOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Request_UpdateLinkOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateLinkOpts != nil {
		l = m.UpdateLinkOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Request_RestoreLinkOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RestoreLinkOpts != nil {
		l = m.RestoreLinkOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Request_DeleteLinkOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteLinkOpts != nil {
		l = m.DeleteLinkOpts.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resp != nil {
		n += m.Resp.Size()
	}
	return n
}

func (m *Response_AddrResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddrResp != nil {
		l = m.AddrResp.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *Response_EmptyResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EmptyResp != nil {
		l = m.EmptyResp.Size()
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}
func (m *AddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovCni(uint64(l))
	}
	return n
}

func (m *EmptyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovCni(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCni(x uint64) (n int) {
	return sovCni(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CNICapArgs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs{`,
		`Option:` + fmt.Sprintf("%v", this.Option) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_PortMapArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_PortMapArg{`,
		`PortMapArg:` + strings.Replace(fmt.Sprintf("%v", this.PortMapArg), "CNICapArgs_PortMap", "CNICapArgs_PortMap", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_BandwidthArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_BandwidthArg{`,
		`BandwidthArg:` + strings.Replace(fmt.Sprintf("%v", this.BandwidthArg), "CNICapArgs_Bandwidth", "CNICapArgs_Bandwidth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IpRangeArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IpRangeArg{`,
		`IpRangeArg:` + strings.Replace(fmt.Sprintf("%v", this.IpRangeArg), "CNICapArgs_IPRange", "CNICapArgs_IPRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DnsConfigArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DnsConfigArg{`,
		`DnsConfigArg:` + strings.Replace(fmt.Sprintf("%v", this.DnsConfigArg), "CNICapArgs_DNSConfig", "CNICapArgs_DNSConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_PortMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_PortMap{`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HostIp:` + fmt.Sprintf("%v", this.HostIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_Bandwidth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_Bandwidth{`,
		`IngressRate:` + fmt.Sprintf("%v", this.IngressRate) + `,`,
		`IngressBurst:` + fmt.Sprintf("%v", this.IngressBurst) + `,`,
		`EgressRate:` + fmt.Sprintf("%v", this.EgressRate) + `,`,
		`EgressBurst:` + fmt.Sprintf("%v", this.EgressBurst) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_IPRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_IPRange{`,
		`Subnet:` + fmt.Sprintf("%v", this.Subnet) + `,`,
		`RangeStart:` + fmt.Sprintf("%v", this.RangeStart) + `,`,
		`RangeEnd:` + fmt.Sprintf("%v", this.RangeEnd) + `,`,
		`Gateway:` + fmt.Sprintf("%v", this.Gateway) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CNICapArgs_DNSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CNICapArgs_DNSConfig{`,
		`Servers:` + fmt.Sprintf("%v", this.Servers) + `,`,
		`Searches:` + fmt.Sprintf("%v", this.Searches) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCapArgs := "[]*CNICapArgs{"
	for _, f := range this.CapArgs {
		repeatedStringForCapArgs += strings.Replace(f.String(), "CNICapArgs", "CNICapArgs", 1) + ","
	}
	repeatedStringForCapArgs += "}"
	keysForCniArgs := make([]string, 0, len(this.CniArgs))
	for k, _ := range this.CniArgs {
		keysForCniArgs = append(keysForCniArgs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForCniArgs)
	mapStringForCniArgs := "map[string]string{"
	for _, k := range keysForCniArgs {
		mapStringForCniArgs += fmt.Sprintf("%v: %v,", k, this.CniArgs[k])
	}
	mapStringForCniArgs += "}"
	s := strings.Join([]string{`&CreateOptions{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`CniArgs:` + mapStringForCniArgs + `,`,
		`CapArgs:` + repeatedStringForCapArgs + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigOptions{`,
		`Ipv4Subnet:` + fmt.Sprintf("%v", this.Ipv4Subnet) + `,`,
		`Ipv6Subnet:` + fmt.Sprintf("%v", this.Ipv6Subnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAddrOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAddrOptions{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateLinkOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateLinkOptions{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Ipv4PodCidr:` + fmt.Sprintf("%v", this.Ipv4PodCidr) + `,`,
		`Ipv6PodCidr:` + fmt.Sprintf("%v", this.Ipv6PodCidr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestoreLinkOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestoreLinkOptions{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteLinkOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteLinkOptions{`,
		`ContainerId:` + fmt.Sprintf("%v", this.ContainerId) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Option:` + fmt.Sprintf("%v", this.Option) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_CreateOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_CreateOpts{`,
		`CreateOpts:` + strings.Replace(fmt.Sprintf("%v", this.CreateOpts), "CreateOptions", "CreateOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_ConfigOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_ConfigOpts{`,
		`ConfigOpts:` + strings.Replace(fmt.Sprintf("%v", this.ConfigOpts), "ConfigOptions", "ConfigOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_GetAddrOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_GetAddrOpts{`,
		`GetAddrOpts:` + strings.Replace(fmt.Sprintf("%v", this.GetAddrOpts), "GetAddrOptions", "GetAddrOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_UpdateLinkOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_UpdateLinkOpts{`,
		`UpdateLinkOpts:` + strings.Replace(fmt.Sprintf("%v", this.UpdateLinkOpts), "UpdateLinkOptions", "UpdateLinkOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_RestoreLinkOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_RestoreLinkOpts{`,
		`RestoreLinkOpts:` + strings.Replace(fmt.Sprintf("%v", this.RestoreLinkOpts), "RestoreLinkOptions", "RestoreLinkOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request_DeleteLinkOpts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request_DeleteLinkOpts{`,
		`DeleteLinkOpts:` + strings.Replace(fmt.Sprintf("%v", this.DeleteLinkOpts), "DeleteLinkOptions", "DeleteLinkOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response{`,
		`Resp:` + fmt.Sprintf("%v", this.Resp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response_AddrResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response_AddrResp{`,
		`AddrResp:` + strings.Replace(fmt.Sprintf("%v", this.AddrResp), "AddressResponse", "AddressResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response_EmptyResp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response_EmptyResp{`,
		`EmptyResp:` + strings.Replace(fmt.Sprintf("%v", this.EmptyResp), "EmptyResponse", "EmptyResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddressResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddressResponse{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmptyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmptyResponse{`,
		`}`,
	}, "")
	return s
}
func valueToStringCni(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CNICapArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNICapArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNICapArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMapArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_PortMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_PortMapArg{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BandwidthArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_Bandwidth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_BandwidthArg{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRangeArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_IPRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_IpRangeArg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsConfigArg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CNICapArgs_DNSConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &CNICapArgs_DnsConfigArg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_PortMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_Bandwidth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bandwidth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bandwidth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressRate", wireType)
			}
			m.IngressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressBurst", wireType)
			}
			m.IngressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IngressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRate", wireType)
			}
			m.EgressRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressBurst", wireType)
			}
			m.EgressBurst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EgressBurst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeStart = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNICapArgs_DNSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Searches", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Searches = append(m.Searches, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CniArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CniArgs == nil {
				m.CniArgs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCni
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCni
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCni
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCni
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCni
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCni
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCni
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCni(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCni
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CniArgs[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapArgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapArgs = append(m.CapArgs, &CNICapArgs{})
			if err := m.CapArgs[len(m.CapArgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6Subnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6Subnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAddrOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAddrOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAddrOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLinkOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLinkOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLinkOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4PodCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4PodCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6PodCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6PodCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoreLinkOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoreLinkOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoreLinkOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteLinkOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteLinkOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteLinkOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= Request_ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_CreateOpts{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_ConfigOpts{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAddrOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAddrOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_GetAddrOpts{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateLinkOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpdateLinkOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_UpdateLinkOpts{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreLinkOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestoreLinkOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_RestoreLinkOpts{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteLinkOpts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteLinkOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Option = &Request_DeleteLinkOpts{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddressResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resp = &Response_AddrResp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EmptyResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resp = &Response_EmptyResp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCni
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCni
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCni
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmptyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCni
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCni(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCni
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCni(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCni
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCni
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCni
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCni
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCni
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCni
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCni        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCni          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCni = fmt.Errorf("proto: unexpected end of group")
)
