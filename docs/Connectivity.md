# Connectivity

Connectivity is the crucial part when you deploy edge devices

## Design

- Communication via `message queue`, so we can control edge devices from anywhere
  - while http is popular for many applications, if you initiate http connection as a client, there can be only one source of control
  - with message queues, you can create multiple producers to control your edge device and they don't even have to know each other
  - with this design, you can control your edge device with your own application along with `aranya`
- Built-in message straming and stream only necessary messages
- Chunked data transmission
- Connectivity fallback
  - if your mqtt broker is unable to handle incoming connection (e.g. tls certificate revoked), you can fallback to another broker for maintenance

## Configuration

```yaml
connectivity:
  # dial timeout
  dialTimeout: 10s

  # initial backoff duration when reconnecting to server/broker
  initialBackoff: 10s

  # max backoff duration when reconnecting to server/broker
  maxBackoff: 3m

  # factor used to multiply backoff duration
  #
  # e.g.
  #   this backoff duration is 10s, if the backoffFactor is 1.5
  #   then the next backoff duration is 15s
  backoffFactor: 1.5

  methods:
    # connectivity method name
    #
    # value can be one of the following:
    #   - mqtt
    #   - grpc
    #   - coap
  - name: mqtt
    # priority of this connectivity method
    priority: 1
    config:
      # maxPayloadSize: # size in bytes

      # variant of mqtt protocol
      #
      # value can be one of the following
      #   - standard (default)
      #   - azure-iot-hub
      #   - gcp-iot-core
      #   - aws-iot-core
      variant: aws-iot-core

      # mqtt broker address
      #
      # in the form of {ADDRESS}:{PORT}
      endpoint: mqtt.example.com:8883

      # transport protocol
      #
      # value can be one of the following
      #   - tcp (default)
      #   - websocket
      transport: tcp

      # custom topic namespace used to pub/sub mqtt topics
      #
      # its meaning depends on the value of variant:
      #
      # for `standard` or `aws-iot-core`
      #       MUST set and following topics will be used:
      #         - ${topicNamespace}/msg
      #         - ${topicNamespace}/cmd
      #         - ${topicNamespace}/status  (will topic)
      #
      # for `gcp-iot-core`
      #       1) when it's empty, mqtt messages will go to registry's default telemetry topic
      #           see https://cloud.google.com/iot/docs/how-tos/mqtt-bridge#publishing_telemetry_events
      #       2) when it's non-empty, it MUST NOT start with a slash (`/`)
      #           its value will be treated as subfolder in gcp-iot-core
      #           see https://cloud.google.com/iot/docs/how-tos/mqtt-bridge#publishing_telemetry_events_to_additional_cloud_pubsub_topics
      #
      # for `azure-iot-hub`
      #       it is the extra property bag in the format of `{key1}={value1}&{key2}={value2}...`
      #       arhat will set property bag to `dev=${DEVICE_ID}&arhat&${topicNamespace}`
      topicNamespaceFrom:
        # read a file, and use the file content as topicNamespace
        #file: /path/to/topicNamespace/file
        # execute a command and take the output as topicNamespace
        #exec: []
        # set topicNamespace explicitly
        text: arhat.dev/aranya/foo

      # clientID
      #
      # its meaning varies when `variant` is different:
      #
      # for `standard`, it's up to your choice
      # for `azure-iot-hub`, it's the `${DEVICE_ID}`
      # for `gcp-iot-core`, it's the `projects/${PROJECT_ID}/locations/${REGION}/registries/${REGISTRY_ID}/devices/${DEVICE_ID}`
      # for `aws-iot-core`, it's up to your iot policies
      clientID: foo

      # username
      #
      # its meaning varies when `variant` is different:
      #
      # for `standard`, it's up to your choice
      # for `azure-iot-hub`, it will be generated by arhat
      # for `gcp-iot-core` or `aws-iot-core`, it's ignored
      username: foo-user

      # password
      #
      # its meaning varies when `variant` is different:
      #
      # for `standard`, it's up to your choice
      # for `azure-iot-hub`, it's the `${DEVICE_SAS_TOKEN}`
      # for `gcp-iot-core` or `aws-iot-core`, it's ignored
      password: my-password

      # tls configuration
      tls:
        # enable tls or not
        enabled: false

        # CA cert file (PEM/ASN.1 format)
        caCert: /path/to/ca.crt
        # You can specify base64 encoded ca cert data directly as an alternative to caCert
        #caCertData: "<base64-encoded-ca-cert>"

        # client cert file (PEM format)
        #
        # for variant `gcp-iot-core`, this field MUST be empty
        cert: /path/to/client.crt
        # You can specify base64 encoded cert data directly as an alternative to cert
        #certData: "<base64-encoded-tls-cert>"

        # client private key file (PEM format)
        #
        # for variant `gcp-iot-core`
        #   the private key is used to sign the JWT token, and its format can also be `ASN.1`
        key:  /path/to/client.key
        # You can specify base64 encoded tls key directly as an alternative to `key`
        #keyData: "<base64-encoded-tls-key>"

        # tls server name override
        serverName: foo.example.com

        # skip verify inscure server cert
        insecureSkipVerify: false

        # ONLY intended for DEBUG use
        #
        # if set, will record the random key used in the tls connection to this file
        # and the file can be used for applications like wireshark to decrypt tls connection
        keyLogFile: /path/to/tmp/tls/log

        # set cipher suites expected to ues when establishing tls connection
        #
        # please refer to [Appendix.B: List of supported cipher suites] for full
        # list of supported cipher suites
        cipherSuites:
        - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256

  - name: grpc
    priority: -1
    config:
      # maxPayloadSize: # size in bytes
      # grpc server address
      endpoint: grpc.example.com

      # TLS settings for grpc connection
      #
      # fields in this section are identical to those in
      # `connectivity.mqttConfig.tls`
      tls:
        enabled: true

  - name: coap
    priority: -100
    config:
      # maxPayloadSize: # size in bytes
      # coap broker address with port
      endpoint: coap.example.com:5684

      # transport protocol
      #
      # value can be one of the following
      #   - udp{,4,6} (defaults to udp)
      #   - tcp{,4,6}
      transport: udp

      # custom path namespace for coap uri-path options
      # usually coap brokers are integrated into mqtt broker
      # so it's like a mqtt topic namespace but with some
      # server specific prefix (ususally `/ps/`)
      pathNamespaceFrom:
        # read a file, and use the file content as pathNamespace
        #file: /path/to/pathNamespace/file
        # execute a command and take the output as pathNamespace
        #exec: []
        # set pathNamespace explicitly
        text: /ps/exmaple/topic/foo

      # custom string key value pair for coap uri-query options
      uriQueries:
        foo: bar
        a: b

      # TLS/DTLS settings for tcp/udp transport
      #
      # most fields in this section are identical to those in
      # `connectivity.mqttConfig.tls` with exceptions noted here
      tls:
        enabled: true

        # allow insecure hash functions
        allowInsecureHashes: false

        # use dtls with pre shared key
        preSharedKey:
          # map server hint(s) to pre shared key(s)
          # column separated base64 encoded key value pairs
          serverHintMapping:
          # empty key to match all server hint
          - :dGhpcyBpcyBteSBwc2s= # `this is my psk`
          - a2V5:dmFsdWU=
          # the client hint provided to server, base64 encoded value
          identityHint: aWRlbnRpdHkgaGludA== # `identity hint`
```

## Appendix.A: List of supported cipher suites

1. TCP TLS

   - `TLS_RSA_WITH_RC4_128_SHA`
   - `TLS_RSA_WITH_3DES_EDE_CBC_SHA`
   - `TLS_RSA_WITH_AES_128_CBC_SHA`
   - `TLS_RSA_WITH_AES_256_CBC_SHA`
   - `TLS_RSA_WITH_AES_128_CBC_SHA256`
   - `TLS_RSA_WITH_AES_128_GCM_SHA256`
   - `TLS_RSA_WITH_AES_256_GCM_SHA384`
   - `TLS_ECDHE_ECDSA_WITH_RC4_128_SHA`
   - `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`
   - `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`
   - `TLS_ECDHE_RSA_WITH_RC4_128_SHA`
   - `TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA`
   - `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`
   - `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`
   - `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`
   - `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`
   - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
   - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
   - `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`
   - `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`
   - `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305`
   - `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305`
   - `TLS_AES_128_GCM_SHA256`
   - `TLS_AES_256_GCM_SHA384`
   - `TLS_CHACHA20_POLY1305_SHA256`
   - `TLS_FALLBACK_SCSV`

2. UDP DTLS

   - `TLS_ECDHE_ECDSA_WITH_AES_128_CCM`
   - `TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8`
   - `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`
   - `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
   - `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`
   - `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`
   - `TLS_PSK_WITH_AES_128_CCM`
   - `TLS_PSK_WITH_AES_128_CCM_8`
   - `TLS_PSK_WITH_AES_128_GCM_SHA256`
